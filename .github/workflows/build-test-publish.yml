# Workflow 1: Build, Test, Publish & Initial Deploy
# This workflow builds the application artifact, builds the Docker image,
# publishes both, and updates the GitOps repository for the initial deployment.

name: Build, Test, Publish & Initial Deploy

on:
  push:
    branches:
      - develop
      - 'release/*'
  workflow_dispatch:
    inputs:
      application_name:
        description: 'Name of the application (e.g., my-service, frontend-app)'
        required: true
        type: string
      initial_deploy_stage:
        description: 'The stage for initial deployment (e.g., dci, uat)'
        required: true
        type: string
        default: 'dci'
      app_version:
        description: 'Manual version override for the application artifact (e.g., 1.0.1). If not provided, it will be determined by .cicd/get-version.sh'
        required: false
        type: string

env:
  # Determine APP_NAME:
  # For manual triggers, it's taken from input.
  # For branch triggers, you might derive it from the repository name,
  # or a file in the repo e.g., jq -r .name .app_descriptor.json
  # This example prioritizes manual input or uses the GitHub repository name as a fallback.
  APP_NAME: ${{ github.event.inputs.application_name || github.repository_owner }}/${{ github.event.repository.name }}
  INITIAL_DEPLOY_STAGE: ${{ github.event.inputs.initial_deploy_stage }}
  ARTIFACT_OUTPUT_DIR: ./dist
  # GITOPS_REPO_URL: Replace with your GitOps repository URL
  # e.g., GITOPS_REPO_URL: git@github.com:your-org/your-gitops-repo.git
  # Or, use a repository variable for this.
  GITOPS_REPO_URL: "git@github.com:your-org/placeholder-gitops-repo.git" # Placeholder
  # ARTIFACTORY_URL: Set in GitHub secrets if using Artifactory for artifacts
  ARTIFACTORY_URL: ${{ secrets.ARTIFACTORY_URL }}
  # DOCKER_REGISTRY_URL: Set in GitHub secrets (e.g., ghcr.io, youracr.azurecr.io)
  DOCKER_REGISTRY_URL: ${{ secrets.DOCKER_REGISTRY_URL }}

jobs:
  build_and_publish_artifact:
    name: Build and Publish Application Artifact
    runs-on: ubuntu-latest
    outputs:
      artifact_name: ${{ steps.version.outputs.ARTIFACT_NAME }}
      artifact_url: ${{ steps.publish_artifact.outputs.artifact_url }}
      app_version: ${{ steps.version.outputs.APP_VERSION }}
      git_hash: ${{ steps.version.outputs.GIT_HASH }}
    steps:
      - name: Checkout Application Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Required for full git history if get-version.sh uses git tags

      - name: Set up Build Environment
        # TODO: Customize this step based on your application's technology stack.
        # For example, for Java:
        # uses: actions/setup-java@v3
        # with:
        #   java-version: '17'
        #   distribution: 'temurin'
        # For Node.js:
        # uses: actions/setup-node@v3
        # with:
        #   node-version: '18'
        run: echo "Build environment setup placeholder. Customize as needed."

      - name: Determine Version
        id: version
        shell: bash
        run: |
          GIT_HASH=$(git rev-parse --short HEAD)
          echo "GIT_HASH=${GIT_HASH}" >> $GITHUB_OUTPUT

          if [[ -n "${{ github.event.inputs.app_version }}" ]]; then
            APP_VERSION="${{ github.event.inputs.app_version }}"
            echo "Using manual version override: $APP_VERSION"
          elif [[ -f ".cicd/get-version.sh" ]]; then
            echo "Attempting to determine version using .cicd/get-version.sh"
            APP_VERSION=$(sh .cicd/get-version.sh)
            if [[ -z "$APP_VERSION" ]]; then
              echo "Warning: .cicd/get-version.sh did not return a version. Falling back to 1.0.0."
              APP_VERSION="1.0.0"
            fi
          else
            echo "Warning: .cicd/get-version.sh not found and no manual version provided. Falling back to 1.0.0."
            APP_VERSION="1.0.0"
          fi
          echo "APP_VERSION=${APP_VERSION}" >> $GITHUB_OUTPUT
          ARTIFACT_NAME="${{ env.APP_NAME }}-${APP_VERSION}-${GIT_HASH}.tar.gz"
          # Clean APP_NAME if it contains slashes (e.g. org/repo)
          ARTIFACT_NAME=$(echo "$ARTIFACT_NAME" | sed 's|/|-|g')
          echo "ARTIFACT_NAME=${ARTIFACT_NAME}" >> $GITHUB_OUTPUT
          echo "Determined Version: $APP_VERSION, Git Hash: $GIT_HASH, Artifact Name: $ARTIFACT_NAME"

      - name: Execute Custom App Build
        # ASSUMPTION: Your custom build script '.cicd/app-build.sh' exists and is executable.
        # This script is responsible for compiling, testing, and packaging your application.
        # It MUST place its final packaged artifact(s) into the directory defined by ARTIFACT_OUTPUT_DIR (./dist).
        run: |
          if [[ ! -f ".cicd/app-build.sh" ]]; then
            echo "Error: .cicd/app-build.sh not found. This script is required to build the application."
            exit 1
          fi
          mkdir -p ${{ env.ARTIFACT_OUTPUT_DIR }}
          sh .cicd/app-build.sh
          echo "Custom app build executed. Ensure artifacts are in ${{ env.ARTIFACT_OUTPUT_DIR }}"

      - name: Archive Artifact
        run: |
          echo "Archiving contents of ${{ env.ARTIFACT_OUTPUT_DIR }} into ${{ steps.version.outputs.ARTIFACT_NAME }}"
          tar czf ${{ steps.version.outputs.ARTIFACT_NAME }} -C ${{ env.ARTIFACT_OUTPUT_DIR }} .
          ls -l ${{ steps.version.outputs.ARTIFACT_NAME }}

      - name: Publish to Artifactory/Packages
        id: publish_artifact
        # TODO: Replace this with your specific artifact publishing mechanism.
        # Example for GitHub Packages (ensure GITHUB_TOKEN has write access to packages):
        # uses: actions/upload-artifact@v3
        # with:
        #   name: ${{ steps.version.outputs.ARTIFACT_NAME }}
        #   path: ${{ steps.version.outputs.ARTIFACT_NAME }}
        #
        # Example for JFrog Artifactory (using jf CLI - requires ARTIFACTORY_URL, ARTIFACTORY_USER, ARTIFACTORY_TOKEN secrets):
        # run: |
        #   jf rt u "${{ steps.version.outputs.ARTIFACT_NAME }}" "your-artifactory-repo/${{ env.APP_NAME }}/" \
        #     --url=${{ secrets.ARTIFACTORY_URL }} \
        #     --user=${{ secrets.ARTIFACTORY_USER }} \
        #     --password=${{ secrets.ARTIFACT_TOKEN }}
        #   # Construct artifact_url based on your Artifactory setup
        #   echo "artifact_url=${{ secrets.ARTIFACTORY_URL }}/your-artifactory-repo/${{ env.APP_NAME }}/${{ steps.version.outputs.ARTIFACT_NAME }}" >> $GITHUB_OUTPUT
        run: |
          echo "Placeholder: Publish artifact ${{ steps.version.outputs.ARTIFACT_NAME }} to chosen repository."
          # For now, using a placeholder URL. Replace with actual URL from your chosen repository.
          echo "artifact_url=https://myartifactrepo.com/path/to/${{ steps.version.outputs.ARTIFACT_NAME }}" >> $GITHUB_OUTPUT
          echo "Artifact URL (placeholder): $(cat $GITHUB_OUTPUT | grep artifact_url)"


  build_and_push_docker_image:
    name: Build and Push Docker Image
    needs: build_and_publish_artifact
    runs-on: ubuntu-latest
    outputs:
      docker_image_tag: ${{ steps.docker_build.outputs.DOCKER_IMAGE_TAG }}
    steps:
      - name: Checkout Application Code
        uses: actions/checkout@v4 # Needed for Dockerfile and .cicd/docker-build.sh

      - name: Login to Docker Registry
        # TODO: Configure login for your specific Docker registry.
        # Example for GitHub Container Registry (GHCR):
        # uses: docker/login-action@v2
        # with:
        #   registry: ghcr.io
        #   username: ${{ github.actor }}
        #   password: ${{ secrets.GITHUB_TOKEN }}
        # Example for Azure Container Registry (ACR):
        # uses: azure/docker-login@v1
        # with:
        #   login-server: ${{ secrets.DOCKER_REGISTRY_URL }} # e.g., youracr.azurecr.io
        #   username: ${{ secrets.DOCKER_REGISTRY_USER }}
        #   password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}
        # Example for Docker Hub:
        # uses: docker/login-action@v2
        # with:
        #   username: ${{ secrets.DOCKER_REGISTRY_USER }}
        #   password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}
        run: |
          echo "Placeholder: Login to Docker Registry (${{ env.DOCKER_REGISTRY_URL }})"
          # Ensure DOCKER_REGISTRY_USER and DOCKER_REGISTRY_PASSWORD secrets are set.
          # For example: echo "${{ secrets.DOCKER_REGISTRY_PASSWORD }}" | docker login ${{ env.DOCKER_REGISTRY_URL }} -u "${{ secrets.DOCKER_REGISTRY_USER }}" --password-stdin

      - name: Download Artifact (if needed by Docker build)
        # This step is optional. Your .cicd/docker-build.sh or Dockerfile might fetch the artifact directly
        # using the artifact_url from the previous job.
        # If your Dockerfile uses ADD <artifact_url>, this step might not be needed.
        # If your Dockerfile expects the artifact locally, download it here.
        # uses: actions/download-artifact@v3
        # with:
        #   name: ${{ needs.build_and_publish_artifact.outputs.artifact_name }}
        #   path: ./downloaded_artifact # Dockerfile can then ADD ./downloaded_artifact/...
        run: echo "Placeholder: Download artifact if Docker build needs it locally. Artifact URL: ${{ needs.build_and_publish_artifact.outputs.artifact_url }}"

      - name: Execute Custom Docker Build and Tag
        id: docker_build
        # ASSUMPTION: Your custom Docker build script '.cicd/docker-build.sh' exists and is executable.
        # This script is responsible for:
        #   1. Building the Docker image (potentially using the downloaded artifact or fetching it).
        #   2. Tagging the image correctly, including the primary tag:
        #      <DOCKER_REGISTRY_URL>/<APP_NAME>:<APP_VERSION>-<GIT_HASH>
        #      (e.g., ghcr.io/myorg/myapi:1.2.0-a1b2c3d)
        #   3. It should echo the full primary Docker image tag as its last output line for capture.
        shell: bash
        run: |
          if [[ ! -f ".cicd/docker-build.sh" ]]; then
            echo "Error: .cicd/docker-build.sh not found. This script is required to build the Docker image."
            exit 1
          fi
          # The script should handle tagging internally and output the primary tag.
          # Example: DOCKER_IMAGE_TAG="${DOCKER_REGISTRY_URL_CLEANED}/${APP_NAME_CLEANED}:${APP_VERSION}-${GIT_HASH}"
          #          echo "DOCKER_IMAGE_TAG=${DOCKER_IMAGE_TAG}" >> $GITHUB_OUTPUT
          # For placeholder, we construct it here:
          APP_NAME_CLEANED=$(echo "${{ env.APP_NAME }}" | sed 's|/|-|g')
          DOCKER_REGISTRY_URL_CLEANED=$(echo "${{ env.DOCKER_REGISTRY_URL }}" | sed 's|https://||g' | sed 's|http://||g') # Ensure no http/https

          PRIMARY_TAG="${DOCKER_REGISTRY_URL_CLEANED}/${APP_NAME_CLEANED}:${{ needs.build_and_publish_artifact.outputs.app_version }}-${{ needs.build_and_publish_artifact.outputs.git_hash }}"
          echo "Executing .cicd/docker-build.sh with:"
          echo "  Artifact URL: ${{ needs.build_and_publish_artifact.outputs.artifact_url }}"
          echo "  App Name: ${APP_NAME_CLEANED}"
          echo "  App Version: ${{ needs.build_and_publish_artifact.outputs.app_version }}"
          echo "  Git Hash: ${{ needs.build_and_publish_artifact.outputs.git_hash }}"
          echo "  Expected Primary Tag: ${PRIMARY_TAG}"

          # This script should build and tag the image.
          # It should also output the DOCKER_IMAGE_TAG for the next step.
          # For this placeholder, we'll just set it.
          # sh .cicd/docker-build.sh \
          #  "${{ needs.build_and_publish_artifact.outputs.artifact_url }}" \
          #  "${APP_NAME_CLEANED}" \
          #  "${{ needs.build_and_publish_artifact.outputs.app_version }}" \
          #  "${{ needs.build_and_publish_artifact.outputs.git_hash }}" \
          #  "${DOCKER_REGISTRY_URL_CLEANED}" # Pass registry URL if script needs it for tagging

          echo "DOCKER_IMAGE_TAG=${PRIMARY_TAG}" >> $GITHUB_OUTPUT
          echo "Custom Docker build executed. Docker Image Tag (placeholder): ${PRIMARY_TAG}"

      - name: Push Docker Image
        # TODO: Replace this with your specific Docker push command.
        # This command should push the primary tag determined in the previous step.
        # Example:
        # docker push ${{ steps.docker_build.outputs.DOCKER_IMAGE_TAG }}
        run: |
          echo "Placeholder: Push Docker image ${{ steps.docker_build.outputs.DOCKER_IMAGE_TAG }}"
          # docker push ${{ steps.docker_build.outputs.DOCKER_IMAGE_TAG }}

  update_gitops_repository:
    name: Update GitOps Repository
    needs: [build_and_publish_artifact, build_and_push_docker_image]
    runs-on: ubuntu-latest
    env:
      # Clean APP_NAME if it contains slashes (e.g. org/repo) for path construction
      APP_NAME_PATH_SAFE: ${{ github.event.inputs.application_name || format('{0}-{1}', github.repository_owner, github.event.repository.name) }}

    steps:
      - name: Checkout GitOps Repository
        uses: actions/checkout@v4
        with:
          repository: ${{ env.GITOPS_REPO_URL }} # e.g., your-org/your-gitops-repo
          # IMPORTANT: You'll need a Personal Access Token (PAT) with write access to the GitOps repository.
          # Store this PAT as a secret named GITOPS_REPO_PAT in your application repository.
          token: ${{ secrets.GITOPS_REPO_PAT }} # Placeholder for the PAT
          # Ensure GITOPS_REPO_PAT is created in the application repository's secrets

      - name: Define Target Path in GitOps Repo
        id: paths
        run: |
          ENVIRONMENT_INSTANCE_PATH="environment_instances/${{ env.APP_NAME_PATH_SAFE }}-${{ env.INITIAL_DEPLOY_STAGE }}"
          echo "ENVIRONMENT_INSTANCE_PATH=${ENVIRONMENT_INSTANCE_PATH}" >> $GITHUB_ENV
          echo "Target path in GitOps repo: ${ENVIRONMENT_INSTANCE_PATH}"
          # Ensure APP_NAME_PATH_SAFE is filesystem-friendly
          # Example: if APP_NAME is "my-org/my-app", APP_NAME_PATH_SAFE becomes "my-org-my-app"

      - name: Update version.yaml in GitOps Repo
        # This step uses 'yq' to update the YAML file. 'yq' might need to be installed.
        # sudo apt-get update && sudo apt-get install -y yq  # If yq is not pre-installed
        # Alternatively, use a Python script or other tool to modify the YAML.
        run: |
          TARGET_VERSION_FILE="${{ env.ENVIRONMENT_INSTANCE_PATH }}/version.yaml"
          echo "Updating GitOps version file: ${TARGET_VERSION_FILE}"
          echo "  Image Tag: ${{ needs.build_and_push_docker_image.outputs.docker_image_tag }}"
          echo "  Artifact URL: ${{ needs.build_and_publish_artifact.outputs.artifact_url }}"

          # Create directory if it doesn't exist
          mkdir -p ${{ env.ENVIRONMENT_INSTANCE_PATH }}

          # Create or update version.yaml
          # This is a simple echo for placeholder. Use a robust YAML updater like yq or a script.
          # Example with yq (ensure yq is installed: sudo apt-get install yq -y):
          # yq eval ".image_tag = \"${{ needs.build_and_push_docker_image.outputs.docker_image_tag }}\"" -i "${TARGET_VERSION_FILE}"
          # yq eval ".artifact_url = \"${{ needs.build_and_publish_artifact.outputs.artifact_url }}\"" -i "${TARGET_VERSION_FILE}"
          # If file doesn't exist, yq might need different handling or create it first.
          # For simplicity, this placeholder overwrites the file:
          cat <<EOL > "${TARGET_VERSION_FILE}"
          image_tag: ${{ needs.build_and_push_docker_image.outputs.docker_image_tag }}
          artifact_url: ${{ needs.build_and_publish_artifact.outputs.artifact_url }}
          EOL
          echo "Contents of ${TARGET_VERSION_FILE}:"
          cat "${TARGET_VERSION_FILE}"

      - name: Commit and Push to GitOps Repository
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add .
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit in GitOps repository."
          else
            git commit -m "Update ${{ env.APP_NAME_PATH_SAFE }} in ${{ env.INITIAL_DEPLOY_STAGE }} to image ${{ needs.build_and_push_docker_image.outputs.docker_image_tag }}"
            echo "Attempting to push changes to GitOps repository..."
            git push
            echo "Changes pushed to GitOps repository."
          fi
        env:
          # Ensure the GITHUB_TOKEN used by actions/checkout (if PAT isn't specified for commit/push)
          # or the GITOPS_REPO_PAT has permissions to push to the GitOps repo.
          # The PAT method used in checkout is generally more reliable for cross-repo pushes.
          GIT_COMMITTER_NAME: github-actions[bot]
          GIT_COMMITTER_EMAIL: github-actions[bot]@users.noreply.github.com
          GIT_AUTHOR_NAME: github-actions[bot]
          GIT_AUTHOR_EMAIL: github-actions[bot]@users.noreply.github.com

# IMPORTANT NOTES AND ASSUMPTIONS:
# 1. User-Provided Scripts:
#    - `.cicd/get-version.sh`: MUST be created by the application team. It determines the application version (e.g., from pom.xml, package.json, git tags).
#    - `.cicd/app-build.sh`: MUST be created by the application team. It builds/compiles/tests the application and places artifacts in `./dist`.
#    - `.cicd/docker-build.sh`: MUST be created by the application team. It builds the Docker image, tags it appropriately (including the primary tag format specified), and should output the primary tag.
#
# 2. Secrets:
#    - `ARTIFACTORY_URL`, `ARTIFACTORY_USER`, `ARTIFACTORY_TOKEN`: For publishing to JFrog Artifactory.
#    - `DOCKER_REGISTRY_URL`, `DOCKER_REGISTRY_USER`, `DOCKER_REGISTRY_PASSWORD`: For Docker registry login and push.
#    - `GITOPS_REPO_PAT`: A GitHub Personal Access Token with write access to the GitOps repository. This is crucial for the `update_gitops_repository` job.
#    - `GITHUB_TOKEN`: Used by default for some actions, ensure it has package write scope if using GitHub Packages.
#
# 3. Placeholders:
#    - Sections marked with "TODO:" or "Placeholder:" require user configuration specific to their artifact repository, Docker registry, and build environment.
#    - The GitOps repository URL (`GITOPS_REPO_URL`) is a placeholder and should be correctly set.
#
# 4. APP_NAME Handling:
#    - The APP_NAME environment variable is constructed to be `owner/repo_name` for branch triggers if not specified by input.
#    - For paths and artifact names, slashes in APP_NAME are replaced with hyphens to ensure valid file/path names.
#      Example: `my-org/my-app` becomes `my-org-my-app`.
#    - `APP_NAME_PATH_SAFE` in the `update_gitops_repository` job is specifically for creating file paths.
#
# 5. yq for YAML manipulation:
#    - The example uses `yq` for updating `version.yaml`. Ensure `yq` is available in the runner or use an alternative method (Python script, sed, etc.).
#      `sudo apt-get update && sudo apt-get install -y yq` can be added to the step if needed.
#
# 6. Initial Directory Creation in GitOps Repo:
#    - The workflow assumes the base directory structure (e.g., `environment_instances/my-app-dci/`) might not exist
#      and attempts to create it (`mkdir -p`). The `version.yaml` is then created or overwritten.
#      Consider if `.gitkeep` files or initial placeholder `version.yaml` files should be pre-populated in the GitOps repo.
#      The current script will create `version.yaml` if it's missing.
#
# 7. Artifact Download in Docker Job:
#    - The workflow includes a placeholder step for downloading the artifact if the Docker build process
#      (`Dockerfile` or `docker-build.sh`) expects the artifact to be present locally.
#      If your `Dockerfile` uses `ADD <artifact_url>`, this might not be necessary.
#
# 8. Error Handling in Scripts:
#    - User-provided scripts (`.cicd/*.sh`) should handle their own error checking and exit with non-zero codes on failure
#      to ensure the GitHub Actions job fails appropriately.
#
# 9. Idempotency of GitOps Update:
#    - The `update_gitops_repository` job, as written, will overwrite `version.yaml`. This is generally fine.
#    - The commit and push step includes a check to see if there are any changes to avoid empty commits.
#
# 10. Docker Image Tagging in docker-build.sh:
#     The `docker-build.sh` script is critical for correctly tagging the Docker image. It must construct and apply a tag
#     in the format `<DOCKER_REGISTRY_URL>/<APP_NAME>:<APP_VERSION>-<GIT_HASH>`.
#     The workflow constructs a `PRIMARY_TAG` as an example and expects `docker-build.sh` to achieve this.
#     The script should also output this primary tag so it can be captured by `steps.docker_build.outputs.DOCKER_IMAGE_TAG`.
